From 90b8ee369938baee931d7020795f9f2b815917d8 Mon Sep 17 00:00:00 2001
From: Ivan Orlov <ivan.orlov0322@gmail.com>
Date: Fri, 12 Jul 2024 22:52:42 +0100
Subject: [PATCH 2/2] ALSA: timer: Introduce userspace-driven timers

There are multiple possible timer sources which could be useful for
the sound time synchronization: hrtimers, hardware clocks (e.g. PTP),
timer wheels (jiffies). Currently, using one of them to synchronize
the audio stream of snd-aloop module would require writing a
kernel-space driver which exports an ALSA timer through the
snd_timer_register interface.

However, it is not really convenient for application writers, who may
want to define their custom timer sources in order to synchronize
substreams of snd-aloop. For instance, we could have a network
application which receives frames and sends them to snd-aloop pcm
device, and another application listening on the other end of snd-aloop.
It makes sense to transfer a new period of data only when certain amount
of bytes is received through the network, but definitely not when a
certain amount of jiffies on a system elapses.

This patch introduces userspace-driven ALSA timers. The timer can be
created from the userspace using the new ioctl SNDRV_TIMER_IOCTL_CREATE.
After creating a timer, it becomes available for use system-wide, so
it can be passed to snd-aloop as a timer source (timer_source parameter
would be "-1.4.{timer_id}"). I believe introducing new ioctl calls is
quite inconvenient (as we have a limited amount of them), but other
possible ways of app <-> kernel communication (like virtual FS) seem
completely inappropriate for this task (but I'd love to discuss
alternative solutions).

So, the ioctl returns a file descriptor of the timer, which can be used
to fire it when the application wants to. If the application wishes to
destroy the timer, it can simply close the file descriptor.

To sum up, the userspace-driven ALSA timers allow us to create virtual
timers which can be used for snd-aloop synchronization.

Signed-off-by: Ivan Orlov <ivan.orlov0322@gmail.com>
---
 include/uapi/sound/asound.h |   9 +++
 sound/core/timer.c          | 135 ++++++++++++++++++++++++++++++++++++
 2 files changed, 144 insertions(+)

diff --git a/include/uapi/sound/asound.h b/include/uapi/sound/asound.h
index 628d46a0da92..9830c7859b61 100644
--- a/include/uapi/sound/asound.h
+++ b/include/uapi/sound/asound.h
@@ -893,6 +893,7 @@ enum {
 #define SNDRV_TIMER_GLOBAL_RTC		1	/* unused */
 #define SNDRV_TIMER_GLOBAL_HPET		2
 #define SNDRV_TIMER_GLOBAL_HRTIMER	3
+#define SNDRV_TIMER_GLOBAL_UDRIVEN	4
 
 /* info flags */
 #define SNDRV_TIMER_FLG_SLAVE		(1<<0)	/* cannot be controlled */
@@ -973,6 +974,12 @@ struct snd_timer_status {
 };
 #endif
 
+struct snd_userspace_timer {
+	snd_pcm_uframes_t rate;
+	snd_pcm_uframes_t period;
+	unsigned int id;
+};
+
 #define SNDRV_TIMER_IOCTL_PVERSION	_IOR('T', 0x00, int)
 #define SNDRV_TIMER_IOCTL_NEXT_DEVICE	_IOWR('T', 0x01, struct snd_timer_id)
 #define SNDRV_TIMER_IOCTL_TREAD_OLD	_IOW('T', 0x02, int)
@@ -989,6 +996,8 @@ struct snd_timer_status {
 #define SNDRV_TIMER_IOCTL_CONTINUE	_IO('T', 0xa2)
 #define SNDRV_TIMER_IOCTL_PAUSE		_IO('T', 0xa3)
 #define SNDRV_TIMER_IOCTL_TREAD64	_IOW('T', 0xa4, int)
+#define SNDRV_TIMER_IOCTL_CREATE	_IOWR('T', 0xa5, struct snd_userspace_timer)
+#define SNDRV_TIMER_IOCTL_FIRE		_IO('T', 0xa6)
 
 #if __BITS_PER_LONG == 64
 #define SNDRV_TIMER_IOCTL_TREAD SNDRV_TIMER_IOCTL_TREAD_OLD
diff --git a/sound/core/timer.c b/sound/core/timer.c
index 4d2ee99c12a3..0f73fe3adc88 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -13,6 +13,7 @@
 #include <linux/module.h>
 #include <linux/string.h>
 #include <linux/sched/signal.h>
+#include <linux/anon_inodes.h>
 #include <sound/core.h>
 #include <sound/timer.h>
 #include <sound/control.h>
@@ -2001,6 +2002,138 @@ enum {
 	SNDRV_TIMER_IOCTL_PAUSE_OLD = _IO('T', 0x23),
 };
 
+static int snd_utimer_release(struct inode *inode, struct file *file)
+{
+	struct snd_timer *timer = (struct snd_timer *)file->private_data;
+
+	snd_timer_free(timer);
+	return 0;
+}
+
+static int fire_timer(struct file *file)
+{
+	struct snd_timer *timer = (struct snd_timer *)file->private_data;
+
+	snd_timer_interrupt(timer, timer->sticks);
+	return 0;
+}
+
+static long snd_utimer_ioctl(struct file *file, unsigned int ioctl, unsigned long arg)
+{
+	switch (ioctl) {
+	case SNDRV_TIMER_IOCTL_FIRE:
+		return fire_timer(file);
+	}
+
+	return -EINVAL;
+}
+
+static const struct file_operations snd_utimer_fops = {
+	.llseek = noop_llseek,
+	.release = snd_utimer_release,
+	.unlocked_ioctl = snd_utimer_ioctl,
+};
+
+static int snd_audiosync_start(struct snd_timer *t)
+{
+	return 0;
+}
+
+static int snd_audiosync_stop(struct snd_timer *t)
+{
+	return 0;
+}
+
+static int snd_audiosync_open(struct snd_timer *t)
+{
+	return 0;
+}
+
+static int snd_audiosync_close(struct snd_timer *t)
+{
+	return 0;
+}
+
+static const struct snd_timer_hardware timer_hw = {
+	.flags = SNDRV_TIMER_HW_AUTO | SNDRV_TIMER_HW_WORK,
+	.open = snd_audiosync_open,
+	.close = snd_audiosync_close,
+	.start = snd_audiosync_start,
+	.stop = snd_audiosync_stop,
+};
+
+static unsigned int timer_id;
+#define NANO_SEC	1000000000UL
+static int snd_utimer_create(struct file *file, struct snd_userspace_timer __user *_utimer)
+{
+	struct snd_userspace_timer *utimer;
+	struct snd_timer *timer;
+	struct snd_timer_id tid;
+	int err;
+	char timer_name[20];
+
+	sprintf(timer_name, "timer%d", timer_id);
+
+	utimer = memdup_user(_utimer, sizeof(*utimer));
+	if (IS_ERR(utimer)) {
+		pr_err("Can't get utimer struct from userspace\n");
+		return -1;
+	}
+
+	timer = kmalloc(sizeof(*timer), GFP_KERNEL);
+	if (!timer) {
+		err = -ENOMEM;
+		goto err_timer_alloc;
+	}
+
+	utimer->id = timer_id;
+	tid.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;
+	tid.dev_class = SNDRV_TIMER_CLASS_GLOBAL;
+	tid.card = -1;
+	tid.device = SNDRV_TIMER_GLOBAL_UDRIVEN;
+	tid.subdevice = timer_id++;
+
+	err = snd_timer_new(NULL, timer_name, &tid, &timer);
+	if (err < 0) {
+		pr_err("Can't create userspace-driven timer\n");
+		err = -EINVAL;
+		goto err_timer_new;
+	}
+
+	timer->module = THIS_MODULE;
+	timer->hw = timer_hw;
+	timer->hw.resolution = NANO_SEC / utimer->rate * utimer->period;
+	timer->hw.ticks = 1;
+	timer->max_instances = 1000;
+
+	err = snd_timer_global_register(timer);
+	if (err < 0) {
+		pr_err("Can't register new timer\n");
+		err = -EFAULT;
+		goto err_timer_reg;
+	}
+
+	err = copy_to_user(_utimer, utimer, sizeof(*utimer));
+	if (err) {
+		pr_err("Failed to copy to userspace\n");
+		err = -EFAULT;
+		goto err_copy_user;
+	}
+
+	kfree(utimer);
+
+	return anon_inode_getfd(timer_name, &snd_utimer_fops, timer, O_RDWR | O_CLOEXEC);
+err_timer_reg:
+err_copy_user:
+	snd_timer_free(timer);
+err_timer_new:
+	kfree(timer);
+err_timer_alloc:
+	kfree(utimer);
+
+	return err;
+}
+
 static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 				 unsigned long arg, bool compat)
 {
@@ -2045,6 +2178,8 @@ static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 	case SNDRV_TIMER_IOCTL_PAUSE:
 	case SNDRV_TIMER_IOCTL_PAUSE_OLD:
 		return snd_timer_user_pause(file);
+	case SNDRV_TIMER_IOCTL_CREATE:
+		return snd_utimer_create(file, argp);
 	}
 	return -ENOTTY;
 }
-- 
2.34.1

