From 7640b43d812bc536081220649ff508c6600bcb43 Mon Sep 17 00:00:00 2001
From: Ivan Orlov <ivan.orlov0322@gmail.com>
Date: Fri, 12 Jul 2024 22:52:42 +0100
Subject: [PATCH 2/2] ALSA: timer: Introduce userspace-driven timers

There are multiple possible timer sources which could be useful for
the sound stream synchronization: hrtimers, hardware clocks (e.g. PTP),
timer wheels (jiffies). Currently, using one of them to synchronize
the audio stream of snd-aloop module would require writing a
kernel-space driver which exports an ALSA timer through the
snd_timer interface.

However, it is not really convenient for application writers, who may
want to define their custom timer sources in order to synchronize
substreams of snd-aloop. For instance, we could have a network
application which receives frames and sends them to snd-aloop pcm
device, and another application listening on the other end of snd-aloop.
It makes sense to transfer a new period of data only when certain amount
of bytes is received through the network, but definitely not when a
certain amount of jiffies on a local system elapses. Since all of the
devices are purely virtual it won't introduce any glitches and will
help the application developers to avoid using sample-rate conversion.

This patch introduces userspace-driven ALSA timers. The timer can be
created from the userspace using the new ioctl SNDRV_TIMER_IOCTL_CREATE.
After creating a timer, it becomes available for use system-wide, so
it can be passed to snd-aloop as a timer source (timer_source parameter
would be "-1.4.{timer_id}"). When the userspace app decides to trigger
a timer, it calls another ioctl SNDRV_TIMER_IOCTL_TRIGGER on the file
descriptor of a timer. It initiates a transfer of a new period of data.

I believe introducing new ioctl calls is quite inconvenient (as we have
a limited amount of them), but other possible ways of app <-> kernel
communication (like virtual FS) seem completely inappropriate for this
task (but I'd love to discuss alternative solutions).

Userspace-driven timers are associated with file descriptors. If the
application wishes to destroy the timer, it can simply close the file.

To sum up, the userspace-driven ALSA timers allow us to create virtual
timers which can be used for snd-aloop synchronization.

Signed-off-by: Ivan Orlov <ivan.orlov0322@gmail.com>
---
 include/uapi/sound/asound.h |   9 +++
 sound/core/timer.c          | 136 ++++++++++++++++++++++++++++++++++++
 2 files changed, 145 insertions(+)

diff --git a/include/uapi/sound/asound.h b/include/uapi/sound/asound.h
index 628d46a0da92..f511ab4d2ff9 100644
--- a/include/uapi/sound/asound.h
+++ b/include/uapi/sound/asound.h
@@ -893,6 +893,7 @@ enum {
 #define SNDRV_TIMER_GLOBAL_RTC		1	/* unused */
 #define SNDRV_TIMER_GLOBAL_HPET		2
 #define SNDRV_TIMER_GLOBAL_HRTIMER	3
+#define SNDRV_TIMER_GLOBAL_UDRIVEN	4
 
 /* info flags */
 #define SNDRV_TIMER_FLG_SLAVE		(1<<0)	/* cannot be controlled */
@@ -973,6 +974,12 @@ struct snd_timer_status {
 };
 #endif
 
+struct snd_userspace_timer {
+	snd_pcm_uframes_t rate;
+	snd_pcm_uframes_t period;
+	unsigned int id;
+};
+
 #define SNDRV_TIMER_IOCTL_PVERSION	_IOR('T', 0x00, int)
 #define SNDRV_TIMER_IOCTL_NEXT_DEVICE	_IOWR('T', 0x01, struct snd_timer_id)
 #define SNDRV_TIMER_IOCTL_TREAD_OLD	_IOW('T', 0x02, int)
@@ -989,6 +996,8 @@ struct snd_timer_status {
 #define SNDRV_TIMER_IOCTL_CONTINUE	_IO('T', 0xa2)
 #define SNDRV_TIMER_IOCTL_PAUSE		_IO('T', 0xa3)
 #define SNDRV_TIMER_IOCTL_TREAD64	_IOW('T', 0xa4, int)
+#define SNDRV_TIMER_IOCTL_CREATE	_IOWR('T', 0xa5, struct snd_userspace_timer)
+#define SNDRV_TIMER_IOCTL_TRIGGER	_IO('T', 0xa6)
 
 #if __BITS_PER_LONG == 64
 #define SNDRV_TIMER_IOCTL_TREAD SNDRV_TIMER_IOCTL_TREAD_OLD
diff --git a/sound/core/timer.c b/sound/core/timer.c
index 4d2ee99c12a3..5b56c774b611 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -13,6 +13,8 @@
 #include <linux/module.h>
 #include <linux/string.h>
 #include <linux/sched/signal.h>
+#include <linux/anon_inodes.h>
+#include <linux/units.h>
 #include <sound/core.h>
 #include <sound/timer.h>
 #include <sound/control.h>
@@ -2001,6 +2003,138 @@ enum {
 	SNDRV_TIMER_IOCTL_PAUSE_OLD = _IO('T', 0x23),
 };
 
+static int snd_utimer_release(struct inode *inode, struct file *file)
+{
+	struct snd_timer *timer = (struct snd_timer *)file->private_data;
+
+	snd_timer_free(timer);
+	return 0;
+}
+
+static int snd_utimer_trigger(struct file *file)
+{
+	struct snd_timer *timer = (struct snd_timer *)file->private_data;
+
+	snd_timer_interrupt(timer, timer->sticks);
+	return 0;
+}
+
+static long snd_utimer_ioctl(struct file *file, unsigned int ioctl, unsigned long arg)
+{
+	switch (ioctl) {
+	case SNDRV_TIMER_IOCTL_TRIGGER:
+		return snd_utimer_trigger(file);
+	}
+
+	return -EINVAL;
+}
+
+static const struct file_operations snd_utimer_fops = {
+	.llseek = noop_llseek,
+	.release = snd_utimer_release,
+	.unlocked_ioctl = snd_utimer_ioctl,
+};
+
+static int snd_utimer_start(struct snd_timer *t)
+{
+	return 0;
+}
+
+static int snd_utimer_stop(struct snd_timer *t)
+{
+	return 0;
+}
+
+static int snd_utimer_open(struct snd_timer *t)
+{
+	return 0;
+}
+
+static int snd_utimer_close(struct snd_timer *t)
+{
+	return 0;
+}
+
+static const struct snd_timer_hardware timer_hw = {
+	.flags = SNDRV_TIMER_HW_AUTO | SNDRV_TIMER_HW_WORK,
+	.open = snd_utimer_open,
+	.close = snd_utimer_close,
+	.start = snd_utimer_start,
+	.stop = snd_utimer_stop,
+};
+
+static unsigned int timer_id;
+static int snd_utimer_create(struct file *file, struct snd_userspace_timer __user *_utimer)
+{
+	struct snd_userspace_timer *utimer;
+	struct snd_timer *timer;
+	struct snd_timer_id tid;
+	int err;
+	char timer_name[20];
+
+	sprintf(timer_name, "timer%d", timer_id);
+
+	utimer = memdup_user(_utimer, sizeof(*utimer));
+	if (IS_ERR(utimer)) {
+		pr_err("Can't get utimer struct from userspace\n");
+		return -EFAULT;
+	}
+
+	timer = kmalloc(sizeof(*timer), GFP_KERNEL);
+	if (!timer) {
+		err = -ENOMEM;
+		goto err_timer_alloc;
+	}
+
+	utimer->id = timer_id;
+	tid.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;
+	tid.dev_class = SNDRV_TIMER_CLASS_GLOBAL;
+	tid.card = -1;
+	tid.device = SNDRV_TIMER_GLOBAL_UDRIVEN;
+	/* We hold the ioctl lock here so we won't get a race condition */
+	tid.subdevice = timer_id++;
+
+	err = snd_timer_new(NULL, timer_name, &tid, &timer);
+	if (err < 0) {
+		pr_err("Can't create userspace-driven timer\n");
+		err = -EINVAL;
+		goto err_timer_new;
+	}
+
+	timer->module = THIS_MODULE;
+	timer->hw = timer_hw;
+	timer->hw.resolution = NANO / utimer->rate * utimer->period;
+	timer->hw.ticks = 1;
+	timer->max_instances = 1000;
+
+	err = snd_timer_global_register(timer);
+	if (err < 0) {
+		pr_err("Can't register new timer\n");
+		err = -EFAULT;
+		goto err_timer_reg;
+	}
+
+	err = copy_to_user(_utimer, utimer, sizeof(*utimer));
+	if (err) {
+		pr_err("Failed to copy to userspace\n");
+		err = -EFAULT;
+		goto err_copy_user;
+	}
+
+	kfree(utimer);
+
+	return anon_inode_getfd(timer_name, &snd_utimer_fops, timer, O_RDWR | O_CLOEXEC);
+err_timer_reg:
+err_copy_user:
+	snd_timer_free(timer);
+err_timer_new:
+	kfree(timer);
+err_timer_alloc:
+	kfree(utimer);
+
+	return err;
+}
+
 static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 				 unsigned long arg, bool compat)
 {
@@ -2045,6 +2179,8 @@ static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 	case SNDRV_TIMER_IOCTL_PAUSE:
 	case SNDRV_TIMER_IOCTL_PAUSE_OLD:
 		return snd_timer_user_pause(file);
+	case SNDRV_TIMER_IOCTL_CREATE:
+		return snd_utimer_create(file, argp);
 	}
 	return -ENOTTY;
 }
-- 
2.34.1

